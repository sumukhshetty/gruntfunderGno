{"version":3,"sources":["../src/lmsr.js"],"names":["calcLMSRCost","calcLMSRProfit","calcLMSROutcomeTokenCount","calcLMSRMarginalPrice","arguments","methodName","functionInputs","name","type","defaults","feeFactor","netOutcomeTokensSold","funding","outcomeTokenIndex","outcomeTokenCount","toString","b","dividedBy","length","ln","times","reduce","acc","numShares","i","plus","exp","minus","ceil","floor","cost","valueOf","div","expOffset","max","sub","tokensSold","add"],"mappings":"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","file":"lmsr.js","sourcesContent":["import { Decimal, normalizeWeb3Args } from './utils'\n\n/**\n * Estimates the cost of buying specified number of outcome tokens from LMSR market.\n * @param {(number[]|string[]|BigNumber[])} opts.netOutcomeTokensSold - Amounts of net outcome tokens that have been sold. Negative amount means more have been bought than sold.\n * @param {(number|string|BigNumber)} opts.funding - The amount of funding market has\n * @param {(number|string|BigNumber)} opts.outcomeTokenIndex - The index of the outcome\n * @param {(number|string|BigNumber)} opts.outcomeTokenCount - The number of outcome tokens to buy\n * @param {(number|string|BigNumber)} opts.feeFactor - The fee factor. Specifying 1,000,000 corresponds to 100%, 50,000 corresponds to 5%, etc.\n * @returns {Decimal} The cost of the outcome tokens in event collateral tokens\n * @alias Gnosis.calcLMSRCost\n */\nexport function calcLMSRCost () {\n    let [[netOutcomeTokensSold, funding, outcomeTokenIndex, outcomeTokenCount, feeFactor]] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'calcLMSRCost',\n            functionInputs: [\n                { name: 'netOutcomeTokensSold', type: 'int256[]' },\n                { name: 'funding', type: 'uint256' },\n                { name: 'outcomeTokenIndex', type: 'uint8' },\n                { name: 'outcomeTokenCount', type: 'uint256' },\n                { name: 'feeFactor', type: 'uint24' },\n            ],\n            defaults: {\n                feeFactor: 0,\n            },\n        })\n\n    outcomeTokenCount = new Decimal(outcomeTokenCount.toString())\n    let b = new Decimal(funding.toString()).dividedBy(new Decimal(netOutcomeTokensSold.length).ln())\n\n    return b.times(\n        netOutcomeTokensSold.reduce((acc, numShares, i) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .plus(i === outcomeTokenIndex ? outcomeTokenCount : 0)\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)).ln()\n        .minus(netOutcomeTokensSold.reduce((acc, numShares) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)).ln()\n        )).times(new Decimal(1).plus(new Decimal(feeFactor).dividedBy(1e6)))\n        .times(1+1e-9).ceil()   // TODO: Standardize this 1e-9 and 1e9 in isClose of tests\n                                //       This is necessary because of rounding errors due to\n                                //       series truncation in solidity implementation.\n}\n\n/**\n * Estimates profit from selling specified number of outcome tokens to LMSR market.\n * @param {(number[]|string[]|BigNumber[])} opts.netOutcomeTokensSold - Amounts of net outcome tokens that have been sold by the market already. Negative amount means more have been sold to the market than sold by the market.\n * @param {(number|string|BigNumber)} opts.funding - The amount of funding market has\n * @param {(number|string|BigNumber)} opts.outcomeTokenIndex - The index of the outcome\n * @param {(number|string|BigNumber)} opts.outcomeTokenCount - The number of outcome tokens to sell\n * @param {(number|string|BigNumber)} opts.feeFactor - The fee factor. Specifying 1,000,000 corresponds to 100%, 50,000 corresponds to 5%, etc.\n * @returns {Decimal} The profit from selling outcome tokens in event collateral tokens\n * @alias Gnosis.calcLMSRProfit\n */\nexport function calcLMSRProfit () {\n    let [[netOutcomeTokensSold, funding, outcomeTokenIndex, outcomeTokenCount, feeFactor]] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'calcLMSRProfit',\n            functionInputs: [\n                { name: 'netOutcomeTokensSold', type: 'int256[]' },\n                { name: 'funding', type: 'uint256' },\n                { name: 'outcomeTokenIndex', type: 'uint8' },\n                { name: 'outcomeTokenCount', type: 'uint256' },\n                { name: 'feeFactor', type: 'uint24' },\n            ],\n            defaults: {\n                feeFactor: 0,\n            },\n        })\n\n    outcomeTokenCount = new Decimal(outcomeTokenCount.toString())\n    let b = new Decimal(funding.toString()).dividedBy(new Decimal(netOutcomeTokensSold.length).ln())\n\n    return b.times(\n        netOutcomeTokensSold.reduce((acc, numShares) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)).ln()\n        .minus(netOutcomeTokensSold.reduce((acc, numShares, i) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .minus(i === outcomeTokenIndex ? outcomeTokenCount : 0)\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)).ln()\n        )).times(new Decimal(1).minus(new Decimal(feeFactor).dividedBy(1e6)))\n        .dividedBy(1+1e-9).floor()  // TODO: Standardize this 1e-9 and 1e9 in isClose of tests\n                                    //       This is necessary because of rounding errors due to\n                                    //       series truncation in solidity implementation.\n}\n\n/**\n * Estimates the number of outcome tokens which can be purchased by specified amount of collateral.\n * @param {(Number[]|string[]|BigNumber[])} opts.netOutcomeTokensSold - Amounts of net outcome tokens that have been sold. Negative amount means more have been bought than sold.\n * @param {(number|string|BigNumber)} opts.funding - The amount of funding market has\n * @param {(number|string|BigNumber)} opts.outcomeTokenIndex - The index of the outcome\n * @param {(number|string|BigNumber)} opts.cost - The amount of collateral for buying tokens\n * @returns {Decimal} The number of outcome tokens that can be bought\n * @alias Gnosis.calcLMSROutcomeTokenCount\n */\nexport function calcLMSROutcomeTokenCount () {\n    // decimal.js making this reaaally messy :/\n    let [[netOutcomeTokensSold, funding, outcomeTokenIndex, cost, feeFactor]] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'calcLMSROutcomeTokenCount',\n            functionInputs: [\n                { name: 'netOutcomeTokensSold', type: 'int256[]' },\n                { name: 'funding', type: 'uint256'},\n                { name: 'outcomeTokenIndex', type: 'uint8'},\n                { name: 'cost', type: 'uint256'},\n                { name: 'feeFactor', type: 'uint24' },\n            ],\n            defaults: {\n                feeFactor: 0,\n            },\n        })\n\n    cost = new Decimal(cost.toString())\n    let b = new Decimal(funding.toString()).dividedBy(new Decimal(netOutcomeTokensSold.length).ln())\n\n    return b.times(\n        netOutcomeTokensSold.reduce((acc, numShares) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .plus(cost.dividedBy(new Decimal(1).plus(new Decimal(feeFactor).dividedBy(1e6))))\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0))\n        .minus(netOutcomeTokensSold.reduce((acc, numShares, i) =>\n            i === outcomeTokenIndex ? acc\n            : acc.plus(\n                new Decimal(numShares.toString())\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)))\n        .ln()).minus(netOutcomeTokensSold[outcomeTokenIndex]).floor()\n}\n\n/**\n * Estimates the marginal price of outcome token.\n * @param {(Number[]|string[]|BigNumber[])} opts.netOutcomeTokensSold - Amounts of net outcome tokens that have been sold. Negative amount means more have been bought than sold.\n * @param {(number|string|BigNumber)} opts.funding - The amount of funding market has\n * @param {(number|string|BigNumber)} opts.outcomeTokenIndex - The index of the outcome\n * @returns {Decimal} The marginal price of outcome tokens. Will differ from actual price, which varies with quantity being moved.\n * @alias Gnosis.calcLMSRMarginalPrice\n */\nexport function calcLMSRMarginalPrice() {\n    let [[netOutcomeTokensSold, funding, outcomeTokenIndex]] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'calcLMSRMarginalPrice',\n            functionInputs: [\n                { name: 'netOutcomeTokensSold', type: 'int256[]' },\n                { name: 'funding', type: 'uint256'},\n                { name: 'outcomeTokenIndex', type: 'uint8'},\n            ]\n        })\n\n    const b = Decimal(funding.valueOf()).div(Decimal.ln(netOutcomeTokensSold.length))\n    const expOffset = Decimal.max(...netOutcomeTokensSold).div(b)\n\n    return Decimal(netOutcomeTokensSold[outcomeTokenIndex].valueOf()).div(b).sub(expOffset).exp().div(\n        netOutcomeTokensSold.reduce(\n            (acc, tokensSold) => acc.add(Decimal(tokensSold.valueOf()).div(b).sub(expOffset).exp()),\n            Decimal(0)\n        )\n    )\n}\n"]}